# Non-Blocking vs Blocking & Async vs Sync

Non-Blocking vs Blocking 과 Async vs Sync는 많은 개발자들이 정의하는 바도 조금씩 다르고, 혼동을 많이 하는 부분 중 하나입니다.

최근 통합 슬랙 봇 프로젝트 과정에서 동기와 비동기를 고민하고 적용해야 하는 부분이 있었는데, 이번 글을 통해서 해당 개념에 대해 간단한 예시와 함게 정리해보는 시간을 가져보려고 합니다.

## Sync(동기)와 Async(비동기)

동기와 비동기의 핵심은 **처리해야 할 작업들을 어떠한 흐름으로 처리**할 것인가로 구분할 수 있습니다. 즉, 호출되는 메서드의 작업 완료 여부 체킹과 메서드의 실행/리턴의 순차적인 흐름을 따르는지를 관점으로 봅니다.

### Sync(동기)

메서드를 호출하는 클라이언트가 메서드를 실행하는 서버의 작업이 완료될 때까지 기다리거나, 바로 리턴받더라도 작업이 미완료 상태이면 작업 완료 여부를 계속 확인하는 것을 **동기**라고 할 수 있습니다.

![image](https://user-images.githubusercontent.com/48710213/192251533-cc81be6d-9531-468b-89d2-ce6eb949828f.png)
### Async(비동기)

메서드를 호출하는 클라이언트가 메서드를 실행하는 서버에 콜백 함수를 함께 전달해서, 서버의 작업이 완료되면 클라이언트에서 보내 준 콜백 함수를 함께 실행한다. 이때 클라이언트는 메서드를 호출하는 후로 메서드의 작업 완료 여부에는 신경을 쓰지 않는 것을 **비동기**라고 할 수 있습니다.

![image](https://user-images.githubusercontent.com/48710213/192251558-a07cf7d6-a4dc-4593-9b13-84dc3e9452dd.png)

## Blocking(블록킹)과 Non-Blocking(논블록킹)

블록킹과 논블로킹의 핵심은 **처리해야 할 작업이, 전체적인 작업 ‘흐름’을 막느냐 안막느냐의 관점**으로 구분할 수 있습니다.

### Blocking(블록킹)

클라이언트가 서버의 메서드를 호출하면, **제어권을 서버에 넘겨주게 된다**고 할 수 있습니다. 이를 순서로 표시하면 다음과 같습니다.

1. 클라이언트가 서버의 메서드를 호출하면, 서버는 제어권을 넘겨받는다.
2. 제어권을 넘겨받은 서버는 메서드를 실행한다. 이때 클라이언트는 제어권이 없기 때문에 제어권이 생길 때까지 대기한다.
3. 서버의 메서드 작업이 종료되면, 클라이언트에게 제어권을 돌려준다.

![image](https://user-images.githubusercontent.com/48710213/192251592-3d45eb48-c015-44fd-b4b3-153ab0baa125.png)

### Non-Blocking(논-블록킹)

클라이언트가 서버의 메서드를 호출해도, **제어권을 클라이언트가 가지고 있는 것**을 말합니다. 역시 순서로 표시하면 다음과 같습니다.

1. 클라이언트가 서버의 메서드를 호출하면, 서버의 메서드는 실행되지만, 제어권을 클라이언트가 가지고 있습니다.
2. 제어권을 클라이언트가 가지고 있기 때문에, 계속 클라이언트의 이후 코드들을 실행합니다.

![image](https://user-images.githubusercontent.com/48710213/192251608-2a48c606-3c51-4f7a-8e65-e1012813e7c1.png)

## Sync vs Async & Blocking vs Non-Blocking 예시

사실 개념만 들었을 때는, 이를 나누는 기준이 조금 불명확하고 햇갈리는 부분이 많을 것 같다는 생각이 듭니다. 예시를 통해서 두 개념이 어떻게 서로 조합되는지 확인해보도록 하겠습니다. 자바 개발자의 조금 더 쉬운 이해를 위해서, 자바의 관점에서 예시코드를 작성해 보았습니다. **예시는 크루간의 리뷰요청 상황**으로 설정 했습니다. 들어가기에 앞서서 이해에 도움이 되는 두 가지 개념을 살펴보고 가겠습니다.

첫번째로는 `개념을 적용하는 관점의 차이`입니다.

**기능을 제공하는 곳에서 동기, 비동기에 대한 개념을 포함하고 있으며, 이를 선택하는 것은 해당 메서드르 호출하는 곳, 즉 클라이언트에서 선택**한다고 할 수 있고, **블로킹, 논블록킹 역시 클라이언트에서 선택**할 수 있습니다.

두번째로는 `Future Interface` 입니다.

**비동기 프로그래밍을 이용하기 위해서 사용하는 Interface** 입니다. 내용이 길어서 자세한 내용은 밑에서 설명하겠습니다.

### Sync & Blocking

동기-블로킹 상황일 때는, 클라이언트가 서버의 리턴값을 필요로 합니다. 또한, 제어권을 서버에 넘겨주고, 서버가 작업을 종료해서 리턴값과 제어권을 돌려줄때까지 기다리게 됩니다.

우리가 개발을 하면서 이러한 예시는 무엇이 있을까요?? 자바를 예시로 들자면 `Console Command`를 입력받는 과정을 `Sync & Blocking` 이라고 할 수 있습니다.

예시 코드를 통해서 다음과 같은 상황을 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/48710213/192251632-f4cea403-7abf-45ca-adf4-7afc67d36962.png)

해당 기능을 보면 루키가 A기능을 리뷰할 때까지 헌치가 기다리고 있는 것을 확인할 수 있습니다. 따라서 한번 리뷰 요청을 받을 때마다 약 3초 이상의 시간이 걸리며, 2번 리뷰를 받을 경우 6초 이상의 시간이 걸린다는 것을 확인할 수 있습니다.

![image](https://user-images.githubusercontent.com/48710213/192251661-ed11a990-7732-4570-83c0-ef45b3cdec88.png)

### Sync & Non-Blocking

동기-논블로킹 상황일 때는, 클라이언트가 서버의 리턴값을 필요로 합니다. 하지만 서버로 제어권을 넘겨주지 않았기 때문에, 클라이언트의 코드를 계속 실행할 수 있습니다.

동기-논블로킹 상황일 때는 어떠한 예시가 있을까요?? 게임 로딩 창을 예시로 들 수 있을 것 같습니다. 클라이언트는 서버에 데이터를 요청한 후, 계속 클라이언트의 작업을 수행합니다. 이때, 지속적으로 서버에 데이터 요청이 종료되었는지 조회를 하면서, 그 조회값을 클라이언트에서 계속 표시해주는 것을 `Sync & Non-Blocking` 이라고 할 수 있습니다.

예시 코드를 통해 다음 상황을 한번 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/48710213/192251679-be1b8337-515a-47ec-b80a-745f9c028428.png)

![image](https://user-images.githubusercontent.com/48710213/192251695-bc2dccca-c07d-4cc4-8915-ed6459dc57ef.png)

해당 기능을 보면 헌치는 루키에게 리뷰 A, 써머에게 리뷰 B를 부탁하고 1초마다 계속 리뷰가 완료되었냐고 물어보고 있습니다.

![image](https://user-images.githubusercontent.com/48710213/192251721-87042de8-6045-41af-a8f1-2a78da8ecef6.png)

만약 루키의 리뷰가 다 완료되었을 경우, 그때 써머의 리뷰가 다 완료되었는지 확인을 하고 아직 완료되지 않았다면 이전과 동일하게 계속 리뷰가 완료되었는지를 확인하는 작업이 이루어집니다.

![image](https://user-images.githubusercontent.com/48710213/192251742-8a9ef49f-9508-48c2-bf23-d57082c036cc.png)

### Async & Non-Blocking

비동기-논블로킹 상황일 때는, 클라이언트가 **서버의 리턴값을 당장 필요로 하지 않고, 서버의 메서드를 호출할 때, 콜백함수를 함께 전달**합니다. 서버는 작업이 끝날 경우, 클라이언트가 전달한 콜백 함수를 실행합니다. 이 과정에서 **클라이언트는 제어권을 서버로 주지 않기 때문에, 서버를 호출한 뒤에도 자신의 작업을 계속 실행**합니다.

예시 코드를 통해 다음 상황을 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/48710213/192251778-d81d8693-177e-4da1-bd75-f9a60cfa0157.png)

![image](https://user-images.githubusercontent.com/48710213/192251799-52a93bda-6e73-4c00-82b8-7d744708f4eb.png)

해당 기능을 보면, 헌치는 루키와 써머에게 각각 리뷰를 요청하고, 본인이 할 일을 수행합니다. 리뷰를 요청받은 루키와 써머는 리뷰를 각각 한 후, 완료가 되면 헌치에게 알림을 보내서 리뷰가 끝났다는 정보를 전달하게 됩니다.

![image](https://user-images.githubusercontent.com/48710213/192252196-d239cd1e-7010-48da-afb4-4217bfc03969.png)
